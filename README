--------------------------------------------------------------------------------
Contact information and license
--------------------------------------------------------------------------------

PropEr (PROPerty-based testing tool for ERlang) is an open-source implementation
of QuickCheck for Erlang developed by Manolis Papadakis (manopapad@gmail.com)
and Kostis Sagonas (kostis@cs.ntua.gr).

Most of the source code of PropEr is written mainly by Manolis Papadakis.

Copyright 2010 by Manolis Papadakis and Kostis Sagonas.

This program is distributed under the GPL, version 3 or later. Please see the
COPYING file for details.


--------------------------------------------------------------------------------
Quickstart guide
--------------------------------------------------------------------------------

* Compile PropEr: run 'make' (or 'make all', if you also want to build the
  documentation).
* Add PropEr's base directory to your ERL_LIBS environment variable - An easy
  way to do this is to add the following line to your ~/.bashrc file:
     export ERL_LIBS=~/path/to/proper
* Add the following include line to all source files containing properties you
  wish to test:
     -include_lib("proper/include/proper.hrl").
  By including this header, all the macros, types and functions described in
  this file are automatically imported, so you can use them without a module
  identifier.
* Compile your source files - remember to export all properties you wish to
  test.
* For each property, run:
     proper:check(your_module:some_property()).
  You can also try out the random instance generation subsystem by running:
     proper_gen:pick(some_type()).
       or
     proper_gen:pick(some_type(), <size>).

Note to users of Erlang r13b03 or older:

PropEr makes heavy use of recursive types, which are unsupported in versions of
the Erlang/OTP distribution prior to r13b04. To compile PropEr under such a
system, run 'make' like so:
  make NOTYPES=1
This enables the spec+type-stripping parse transform included in PropEr, which
fixes the problem by stripping all type information from PropEr's source files
while compiling.


--------------------------------------------------------------------------------
Introduction
--------------------------------------------------------------------------------

Traditional testing methodologies essentially involve software testers writing a
series of test inputs for their programs, along with their corresponding
expected outputs, then running the program with these inputs and observing
whether it behaves as expected. This method of testing, while simple and easy to
automate, suffers from a few problems, such as:
* Writing test cases by hand is tedious and time consuming.
* It is hard to know whether the test suite covers all aspects of the software
  under test.

Property-based testing is a novel approach to software testing, where the tester
needs only specify the generic structure of valid inputs for the program under
test, plus certain properties (regarding the program's behaviour and the input-
output relation) which are expected to hold for every valid input. A property-
based testing tool, when supplied with this information, should randomly
produce progressively more complex valid inputs, then apply those inputs to the
program while monitoring its execution, to ensure that it behaves according to
its specification, as outlined in the supplied properties.

Here are a few examples of simple properties a user may wish to test, expressed
in natural language:
* The program should accept any character string and convert all lowercase
  letters inside the string to uppercase.
* The program should accept any list of integers. If the input list is at least
  4 elements long, the program should return the 4th largest integer in the
  list, else it should throw an exception.

PropEr is such a property-based testing tool, designed to test programs written
in the Erlang programming language. Its focus is on testing the behaviour of
pure functions. The input domain of functions is specified through the use of
a type system, modeled closely after the type system of the language itself
(see the following sections for details). Properties are written using Erlang
expressions, with the help of a few predefined macros.


--------------------------------------------------------------------------------
How to write properties (test case generators)
--------------------------------------------------------------------------------

The simplest properties that PropEr can test consist of a single boolean
expression (or a statement block that returns a boolean), which is expected to
evaluate to 'true'. More complex (and useful) properties can be written by
wrapping such a boolean expression with one or more of the following wrappers:

?FORALL(<Xs>, <Xs_type>, <Prop>)
    The <Xs> field can either be a single variable, a tuple of variables or a
    list of variables. The <Xs_type> field must then be a single type, a tuple
    of types of the same length as the tuple of variables or a list of types of
    the same length as the list of variables, respectively. Tuples and lists
    can be combined in any way, as long as <Xs> and <Xs_type> are compatible.
    All the variables inside <Xs> can (and should) be present as free variables
    inside the wrapped property <Prop>. When a ?FORALL wrapper is encountered, a
    random instance of <Xs_type> is produced and each variable in <Xs> is
    replaced inside <Prop> by its corresponding instance.
?FORALL_B(<Xs>, <Xs_built-in_type_in_a_string>, <Prop>),
    Equivalent to a normal ?FORALL, but the type of <Xs> is provided using the
    built-in type language of Erlang. See the 'Reading built-in types' section
    for more details.
?IMPLIES(<Precondition>, <Prop>)
    This wrapper only makes sense when in the scope of at least one ?FORALL. The
    <Precondition> field must be a boolean expression or a statement block that
    returns a boolean. If the precondition evaluates to 'false' for the variable
    instances produced in the enclosing ?FORALL wrappers, the test case is
    rejected (it doesn't count as a failing test case), and PropEr starts over
    with a new random test case. Also, in verbose mode, an 'x' is printed on
    screen.
collect(<Category>, <Prop>)
    The <Category> field can be an expression or statement block that evaluates
    to any term - the test case produced will be categorized under this term.
    All produced categories are printed at the end of testing (in case no test
    fails) along with the percentage of test cases belonging to each category.
    Multiple 'collect' wrappers are allowed in a single property, in which case
    the percentages for each 'collect' wrapper are printed separately.
collect(<Stats_printer>, <Category>, <Prop>)
    Same as collect/2, but takes an extra first argument, which should be a fun
    with one of the following signatures:
    (SortedSample :: [term()]) -> 'ok'
    (SortedSample :: [term()], TestsPassed :: pos_integer()) -> 'ok'
    This fun will be called at the end of testing (in case no test fails) with
    a sorted list of collected terms and, in the case of the 2-argument variant,
    the number of tests that actually succeeded. It is expected to print some
    statistics over the collected terms. with_title/1 is a predefined function
    that accepts an atom or string and returns a stats printing function which
    is equivalent to the default one, but prints the given title above the
    statistics.
aggregate(<Categories>, <Prop>)
    Same as collect/2, but accepts a list of categories under which to classify
    the produced test case.
aggregate(<Stats_printer>, <Categories>, <Prop>)
    Same as collect/3, but accepts a list of categories under which to classify
    the produced test case.
measure(<Title>, <Number> | <List_of_numbers>, <Prop>)
    The number (or numbers) provided are collected and some numeric statistics
    over the collected sample are printed at the end of testing (in case no test
    fails), prepended with <Title>, which should be an atom or string.
?WHENFAIL(<Action>, <Prop>)
    The <Action> field should contain an expression or statement block that
    produces some side-effect (e.g. prints something to the screen). In case
    this test fails, <Action> will be executed. Note that the output of such
    actions is not affected by the verbosity setting of the main application.
?TRAPEXIT(<Prop>)
    Signifies that the code comprising <Prop> may report failure by exiting
    abnormally, e.g. if it spawns and links to a worker thread, the worker
    thread crashes and the parent thread was not trapping exits itself. The
    <Prop> field cannot contain any ?FORALL or ?FORALL_B macros.
?TIMEOUT(<Time_limit>, <Prop>)
    Signifies that <Prop> should be considered failing if it takes more than
    <Time_limit> milliseconds to return. The purpose of this wrapper is to test
    code that may hang if something goes wrong. The <Prop> field cannot contain
    any ?FORALL, ?FORALL_B or ?TIMEOUT macros.

The following predefined properties may be used in place of a simple boolean
expression as the innermost property:

equals(<A>, <B>)
    Returns true if <A> =:= <B>, else returns false and prints "<A> =/= <B>" on
    screen.

Additionally, a property may be wrapped with one or more of the following
outer-level wrappers, which control the behaviour of the testing subsystem:

numtests(<Positive_number>, <Prop>)
    Specifies the number of tests to run. Default is 100.
fails(<Prop>)
    Specifies that we expect the property to fail for some input. The property
    will be considered failing if it passes all the tests.
on_output(<Output_function>, <Prop>)
    Specifies an output function to be used by PropEr for all output printing.
    This wrapper is equivalent to the 'on_output' option (see the 'Options'
    section for details).

Note that failure of a property may also be signified by throwing an exception
(but not an error).

For some actual usage examples, see the code in the examples directory. The
testing modules in the tests directory may also be of interest.


--------------------------------------------------------------------------------
Program behaviour
--------------------------------------------------------------------------------

When running in verbose mode (this is the default), each succeeding test prints
a '.' on screen. If a test fails, a '!' is printed, along with the failing
test case (the instances of the types in every ?FORALL) and the cause of the
failure, if it was not simply the falsification of the property. Then, unless
the test was expected to fail, PropEr attempts to produce a minimal test case
that fails the property in the same way. This process is called
'shrinking'. During shrinking, a '.' is printed for each successful
simplification of the failing test case. When PropEr reaches its shrinking limit
or realizes that the instance cannot be shrunk further while still failing the
test, it prints the minimal failing test case and failure reason and exits.

The return value of PropEr can be one of the following:

* 'true': The property held for all valid produced inputs.
* 'false': The property failed for some input.
* {'error', <Type_of_error>}: An error occured - see the 'Errors' section for a
  description of possible errors.

In long-result mode (see the 'Options' section), a tagged tuple is returned,
detailing the results of testing. The return tuple can be one of the following:

* {'passed', <Number_of_tests_passed>, <List_of_categories_lists>}: The property
  held for all <Number_of_tests_passed> valid produced inputs. The third element
  of the return tuple is a list containing one list of collected categories for
  each separate 'collect' or 'aggregate' clause in the test property.
* {'failed', <After_so_many_tests>, <Counterexample>}: The property failed for
  the input contained in <Counterexample> (see the 'Counterexamples' section).
  PropEr had been instructed not to attempt shrinking on this input.
* {'failed', <After_so_many_tests>, <Original_counterexample>,
   <Number_of_shrinks>, <Simplified_counterexample>}: The property failed for
  the input contained in <Original_counterexample>, which has been shrunk to the
  minimal failing input contained in <Simplified_counterexample> (see the
  'Counterexamples' section).
* {'error', <Type_of_error>}: An error occured - see the 'Errors' section for a
  description of possible errors.


--------------------------------------------------------------------------------
Counterexamples
--------------------------------------------------------------------------------

The last (simplest) counterexample produced by PropEr during a testing run can
be retrieved after testing has finished, by running proper:get_counterexample().
To enable this functionality, some information has to remain in the process
dictionary even after proper:check has returned. To completely clean up the
process dictionary of PropEr-produced entries, run proper:clean_garbage().
Counterexamples can also be retrieved by running PropEr in long-result mode, in
which case counterexamples are also returned as part of the return tuple.

Apart from the actual produced instances of the types in ?FORALL wrappers, a
counterexample contains some additional information that PropEr needs in order
to re-check a failing test case. Use the following functions to extract the
useful parts of a counterexample:
* proper:get_bound/1: Extracts the actual test case (produced instances of types
  in ?FORALLs).
* proper:get_fail_reason/1: Extracts a term representing the cause of failure.
  Possible failure reasons are:
  - 'false_prop': The property evaluates to 'false' for this test case.
  - 'timeout': Evaluation of the property exceeded the time limit specified in
    a ?TIMEOUT clause.
  - {'exception',<Kind>,<Reason>,<Stacktrace>}: A <Kind>:<Reason> exception
    was thrown by the property evaluation code.


--------------------------------------------------------------------------------
Options
--------------------------------------------------------------------------------

Options can be provided as a second argument to proper:check. A single option
can be written stand-alone, or multiple options can be provided in a list.
Unrecognized options are ignored. The available options are:

'quiet'
    Enables quiet mode - no output is printed on screen while PropEr is running.
{'to_file', <IO_device>}
    Redirects all of PropEr's output to <IO_device>, which should be an IO
    device associated with a file opened for writing.
{'on_output', <output_function>}
    PropEr will use the supplied function for all output printing. This function
    should accept two arguments in the style of io:format/2.
    CAUTION: If multiple of the above three output control options are provided,
    the last one in the list takes precedence.
'long_result'
    Enables long-result mode (see the 'Program behaviour' section for details).
'crypto'
    Enables the use of the crypto module for some kinds of random generation
    (namely, the generation of binaries and the generation of ranges of
    integers) - make sure the crypto module is available before enabling this.
    This has the side-effect that an INFO message is printed on screen when
    the program exits, because of the stopping of the crypto server.
    CAUTION: This option is incompatible with the random function generation
    subsystem - do not enable it for tests that contain randomly generated
    functions.
{'numtests', <Positive_number>} or simply <Positive_number>
    This is equivalent to the 'numtests' property wrapper. Any 'numtests'
    wrappers in the actual property will overwrite this setting.
{'start_size', <Size>}
    Specifies the initial value of the 'size' parameter (default is 1), see the
    'Basic types' section for details.
{'max_shrinks', <Non_negative_number>}
    Specifies the maximum number of times a failing test case should be shrunk
    before returning. Note that the shrinking may stop before so many shrinks
    are achieved if the shrinking subsystem deduces that it cannot shrink the
    failing test case further. Default is 500.
'noshrink'
    Instructs PropEr to not attempt to shrink any failing test cases.
{'constraint_tries', <Positive_number>}
    Specifies the maximum number of tries before the generator subsystem gives
    up on producing an instance that satisfies a ?SUCHTHAT constraint. Default
    is 50.
'fails'
    This is equivalent to the 'fails' property wrapper.


--------------------------------------------------------------------------------
Basic types
--------------------------------------------------------------------------------

The following basic types are provided:

* integer() : all integers,
    also written as largeint() for compatibility with QuickCheck,
    the shrinking subsystem will attempt to shrink instances of this type to
    values as close as possible to 0
* integer(Low,High) : integers between 'Low' and 'High', bounds included,
    also written as choose(Low,High) and range(Low,High),
    Low and High must be Erlang expressions that evaluate to integers, with
    Low =< High,
    instances shrink towards the bound with the smallest absolute value
* non_neg_integer() : all non-negative integers,
    instances shrink towards 0
* pos_integer() : all positive integers,
    instances shrink towards 1
* neg_integer() : all negative integers,
    instances shrink towards -1
* float() : all floating point numbers,
    also written as real() for compatibility with QuickCheck,
    instances shrink towards 0.0
* float(Low,High) : all floats between 'Low' and 'High', bounds included,
    Low and High must be Erlang expressions that evaluate to floats, with
    Low =< High,
    instances shrink towards the bound with the smallest absolute value
* number() : all numbers (integers and floats),
    instances shrink towards zero (0 or 0.0)
* byte() : all integers between 0 and 255,
    instances shrink towards 0
* char() : all integers between 0 and 16#10ffff,
    instances shrink towards the NUL character, \000
* binary() : all binaries,
    instances shrink towards the empty binary, <<>>
* bitstring() : all bitstrings,
    instances shrink towards the empty bitstring, <<>>
* atom() : all atoms, except those starting with '$'
    you should not use any atoms starting with a '$', as these may clash
    with atoms used internally by PropEr,
    instances shrink towards the empty atom, ''
* boolean() : the atoms 'true' or 'false',
    also written as bool() for compatibility with QuickCheck,
    instances shrink towards 'false'
* list(ElemType) : all lists containing elements of type ElemType,
    instances shrink towards the empty list, []
* list() : equivalent to list(any())
* string() : all lists of characters,
    instances shrink towards the empty string, ""
* function(ArgTypes, RetType) : all pure functions that map instances of
    ArgTypes (ArgTypes must be provided in a list) to instances of RetType,
    the syntax function(Arity, RetType) is also acceptable
* any() : all Erlang terms (that PropEr can produce)
    also written as term()
    currently, functions are never produced as instances of any()

All the above have analogues in the built-in types of the Erlang language.

In addition, the following types are provided:

* int() : small integers (bound by the current value of the 'size' parameter -
    see the next section for details),
    instances shrink towards 0
* nat() : small non-negative integers (bound by the current value of the 'size'
    parameter - see the next section for details),
    instances shrink towards 0
* non_neg_float() : all non-negative floats,
    instances shrink towards 0.0
* binary(Len) : all binaries with a byte size of 'Len',
    Len must be an Erlang expression that evaluates to a non-negative integer,
    instances shrink towards binaries of zeroes
* bitstring(Len) : all bitstrings with a bit size of 'Len',
    Len must be an Erlang expression that evaluates to a non-negative integer,
    instances shrink towards bitstrings of zeroes
* tuple(ListOfTypes) : all tuples whose i-th element is an instance of the type
    at index i of ListOfTypes,
    also written simply as a tuple of types
* loose_tuple(ElemType) : all tuples whose elements are all of type ElemType
    instances shrink towards {}
* tuple() : equivalent to loose_tuple(any())
* vector(Len,ElemType) : all lists of length Len containing elements of type
    ElemType,
    Len must be an Erlang expression that evaluates to a non-negative integer
* fixed_list(ListOfTypes) : all lists whose i-th element is an instance of the
    type at index i of ListOfTypes,
    also written simply as ListOfTypes
* orderedlist(ElemType) : all sorted lists containing elements of type ElemType,
    instances shrink towards the empty list, []
* exactly(X) : singleton type consisting only of X,
    X must be an evaluated term,
    also written as return(X) or simply as X
* union(ListOfTypes) : the union of all types in ListOfTypes,
    ListOfTypes can't be empty,
    the random instance generator is equally likely to choose any one of the
    types in ListOfTypes,
    the shrinking subsystem will always try to shrink an instance of a type
    union to an instance of the first type in ListOfTypes, thus you should write
    the simplest case first,
    also written as oneof(ListOfTypes) and elements(ListOfTypes)
* weighted_union(ListOfTypes) : a specialization of union(ListOfTypes) where
    each type in ListOfTypes is assigned a frequency like so: {frequency,type},
    frequencies must be Erlang expressions that evaluate to positive integers,
    types with larger frequencies are more likely to be chosen by the random
    instance generator,
    the shrinking subsystem will ignore the frequencies and try to shrink
    towards the first type in ListOfTypes,
    also written as wunion(ListOfTypes) and frequency(ListOfTypes)
* default(Default, Type) : adds a default value, Default, to Type,
    the default serves as a primary shrinking target for instances, while it is
    also chosen by the random instance generation subsystem half the time
* function[0-4](RetType) : equivalent to function([0-4], RetType), provided for
    compatibility with QuickCheck
* timeout() : equivalent to union([non_neg_integer() | 'timeout']),
    instances shrink towards 0

As you can see from the above descriptions, types can be combined in tuples or
lists to produce other types, while exact values (such as exact numbers, atoms
or strings) can be combined with types inside such structures, like in this
example of the type of a tagged tuple: {'result', integer()}.


--------------------------------------------------------------------------------
How to construct types
--------------------------------------------------------------------------------

The following macros and functions can be applied to types in order to produce
new ones:

?LET(<Xs>, <Xs_type>, <In>)
    To produce an instance of this type, all appearances of the variables in
    <Xs> inside <In> are replaced by their corresponding values in a randomly
    generated instance of <Xs_type>. It's OK for the <In> part to evaluate to a
    type - in that case, an instance of the inner type is generated recursively.
?SUCHTHAT(<X>, <Type>, <Condition>)
    This produces a specialization of <Type>, which only includes those members
    of <Type> that satisfy the constraint <Condition> - that is, those members
    for which the function 'fun(<X>) -> <Condition> end' returns true. If the
    constraint is very strict - that is, only a small percentage of instances
    of <Type> pass the test - it will take a lot of tries for the instance
    generation subsystem to randomly produce a valid instance of the specialized
    type. This will result in slower testing - testing may even be stopped
    short, in case the 'constraint_tries' limit is reached (see the 'Options'
    section). If this is the case, it would be more appropriate to generate
    valid instances of the specialized type using the ?LET macro.
?SUCHTHATMAYBE(<X>, <Type>, <Condition>)
    Equivalent to the ?SUCHTHAT macro, but the constraint <Condition> is
    considered non-strict: if the 'constraint_tries' limit is reached, the
    generator will just return an instance of <Type> instead of failing,
    even if that instance doesn't satisfy the constraint.
non_empty(<List_type>)
    This is a predefined constraint that can be applied to random-length list
    types (e.g. list() and string()) to ensure that the produced lists are not
    empty.
noshrink(<Type>)
    Creates a new type which is equivalent to <Type>, but whose instances are
    never shrunk by the shrinking subsystem.
?SHRINK(<Generator>, <List_of_alternative_generators>)
    This creates a type whose instances are generated by evaluating the
    statement block <Generator> (this may evaluate to a type, which is generated
    recursively). If an instance of such a type is to be shrunk, the generators
    in <List_of_alternative_generators> are first run to produce hopefully
    simpler instances of the type. Thus, the generators in the second argument
    should be simpler than the default. The simplest ones should be at the front
    of the list, since those are the generators preferred by the shrinking
    subsystem. Like the main <Generator>, the alternatives may also evaluate to
    a type, which is generated recursively.
?LETSHRINK(<List_of_variables>, <List_of_types>, <Generator>)
    This is created by combining a ?LET and a ?SHRINK macro. Instances are
    generated by applying a randomly generated list of values inside <Generator>
    (just like a ?LET, only the variables and types must always be in a list).
    When shrinking instances of such a type, the types inside <List_of_types>
    are first tried in place of the parent type.
?LAZY(<Generator>)
    This construct returns a type whose only purpose is to delay the evaluation
    of <Generator> (<Generator> can return a type, which will be generated
    recursively). Using this, you can simulate the lazy generation of instances:
      stream() -> ?LAZY(frequency([ {1,[]}, {3,[0|stream()]} ])).
    The above type produces lists of zeroes with an average length of 3. Note
    that, had we not enclosed the generator with a ?LAZY macro, the evaluation
    would continue indefinitely, due to the eager evaluation of the Erlang
    language.

The following functions and macros are related to the 'size' parameter, which
controls the maximum size of produced instances. The actual size of a produced
instance is chosen randomly, but can never exceed the value of the 'size'
parameter at the moment of generation. A more accurate definition is the
following: the maximum instance of 'size' S can never be smaller than the
maximum instance of 'size' S-1. The actual size of an instance is measured
differently for each type: the actual size of a list is its length, while the
actual size of a tree may be the number of its internal nodes. Some types, e.g.
unions, have no notion of size, thus their generation is not influenced by the
value of 'size'. The 'size' parameter starts at 0 and grows automatically during
testing.

?SIZED(<S>, <Generator>)
    Creates a new type, whose instances are produced by replacing all
    appearances of the <S> parameter inside the statement block <Generator> with
    the value of the 'size' parameter. It's OK for the <Generator> to return a
    type - in that case, an instance of the inner type is generated recursively.
resize(<New_size>, <Type>)
    Overrides the 'size' parameter used when generating instances of <Type> with
    <New_size>. Has no effect on size-less types, such as unions. Also, this
    will not affect the generation of any internal types contained in <Type>,
    such as the elements of a list - those will still be generated using the
    test-wide value of 'size'. One use of this function is to modify types to
    grow faster or slower, like so:
      ?SIZED(Size, resize(Size * 2, list(integer()))
    The above specifies a list type that grows twice as fast as normal lists.


--------------------------------------------------------------------------------
Reading built-in types
--------------------------------------------------------------------------------

PropEr can parse types expressed in Erlang's built-in type format and convert
them to its native type format. Such expressions can be provided in string form
as the second argument of a ?FORALL_B macro, in place of the PropEr type-style
argument of normal ?FORALLs, and are subject to the following usage rules:

* They may contain any Erlang type construct, such as '[...]', '{...}' or '|'.
* They may reference types declared in -type attributes, so long as these types
  are exported from their respective modules, or they are declared in the same
  module as the ?FORALL_B macro which contains the type expression.
* They may contain references to self-recursive or mutually recursive types, as
  long as each type in the hierarchy has a clear base case. Currently, PropEr
  requires that the toplevel of any recursive type declaration is either a
  (maybe empty) list or a union containing at least one choice that doesn't
  reference the type (it may, however, reference any of the types that are
  mutually recursive with this one). This means, for example, that some valid
  recursive type declarations, such as this one:
    ?FORALL_B(..., "a()", ...) where:
    -type a() :: {'a','none' | a()}.
  are not accepted by PropEr. However, such types can be rewritten in a way that
  allows PropEr to parse them:
    ?FORALL_B(..., "a()", ...) where:
    -type a() :: {'a','none'} | {'a',a()}.
  This also means that recursive record declarations are not allowed:
    ?FORALL_B(..., "#rec{}", ...) where:
    -record(rec, {a = 0 :: integer(), b = 'nil' :: 'nil' | #rec{}}).
  A little rewritting can usually remedy this problem as well:
    ?FORALL_B(..., "rec()", ...) where:
    -record(rec, {a = 0 :: integer(), b = 'nil' :: 'nil' | #rec{}}).
    -type rec() :: #rec{b :: 'nil'} | #rec{b :: rec()}.
* For a ?FORALL_B macro to function properly, both the module that contains it,
  as well as any module that contains the declaration of a type referenced
  (directly or indirectly) from inside the type expression of the ?FORALL_B
  must have been compiled with debug_info enabled and must be present in the
  codepath at the time of testing.
* Parametric types are fully supported. Of course, they can only appear
  instantiated inside the type expression of a ?FORALL_B.
* Inline record-field type declarations that reference non-existent field and
  type variables that are not present in the RHS of a -type declaration are
  silently ignored.


--------------------------------------------------------------------------------
Symbolic datatypes
--------------------------------------------------------------------------------

Coming soon.


--------------------------------------------------------------------------------
Errors
--------------------------------------------------------------------------------

The following errors may be encountered during testing. The term provided for
each error is the error type returned by proper:check in case such an error
occurs. Normaly, a message is also printed on screen describing the error.

* 'cant_generate': The instance generation subsystem has failed to produce an
  instance that satisfies some ?SUCHTHAT constraint. You should either increase
  the 'constraint_tries' limit, loosen the failing constraint, or make it
  non-strict.
* 'cant_satisfy': All the tests were rejected because no produced test case
  would pass all ?IMPLIES checks. You should loosen the failing ?IMPLIES
  constraint(s).
* 'type_mismatch': The variables' and types' structures inside a ?FORALL don't
  match. Please check your properties.
* {'typeserver', <SubError>}: The typeserver couldn't process a built-in type
  inside a ?FORALL_B. The <SubError> field contains specific information
  regarding the error.
* {'unexpected', <Result>}: A test returned an unexpected result. If you ever
  get this error, it means that you have found a bug in PropEr - please send an
  error report to the maintainers and remember to include both the failing test
  case and the output of the program, if possible.


--------------------------------------------------------------------------------
Incompatibilities with Quviq QuickCheck
--------------------------------------------------------------------------------

We have generaly tried to keep PropEr's notation and output as compatible as
possible with Quviq QuickCheck, to allow for the reuse of existing testing code
written for QuickCheck. However, incompatibilities are to be expected, since
the two programs probably bear little resemblance under the hood. Here we
provide a nonexhaustive list of known incompatibilities:

* ?SUCHTHATMAYBE behaves differently in PropEr.
* In order to re-check a failing test case, PropEr requires more than the
  instances of the failing test case itself. That required extra bit of
  information is the reason for encapsulating the failing test case in an opaque
  'counterexample' datatype.
* proper_gen:pick differs from eqc_gen:pick in return value format.
* PropEr handles 'size' differently from QuickCheck.
