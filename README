--------------------------------------------------------------------------------
Contact information and license
--------------------------------------------------------------------------------

PropEr is Copyright 2010 Manolis Papadakis (manopapad@gmail.com).

Contributions by:
* Kostis Sagonas (kostis@cs.ntua.gr)

This program is distributed under the GPL, version 3 or later. Please see the
COPYING file for details.


--------------------------------------------------------------------------------
Quickstart guide
--------------------------------------------------------------------------------

* Compile PropEr: run 'make' (or 'make all', if you also want to build the
  documentation).
* Add PropEr's base directory to your ERL_LIBS environment variable - An easy
  way to do this is to add the following line to your ~/.bashrc file:
     export ERL_LIBS=~/path/to/proper
* Add the following include line to all source files containing properties you
  wish to test:
     -include_lib("proper/include/proper.hrl").
  By including this header, all the macros, types and functions described in
  this file are automatically imported, so you can use them without a module
  identifier.
* Compile your source files - remember to export all properties you wish to
  test.
* For each property, run:
     proper:check(your_module:some_property()).
  You can also try out the random instance generation subsystem by running:
     proper_gen:pick(some_type()).


--------------------------------------------------------------------------------
How to write properties (test case generators)
--------------------------------------------------------------------------------

The simplest properties that PropEr can test consist of a single boolean
expression (or a statement block that returns a boolean), which is expected to
evaluate to 'true'. More complex (and useful) properties can be written by
wrapping such a boolean expression with one or more of the following wrappers:

?FORALL(<Xs>, <Xs_type>, <Prop>)
    The <Xs> field can either be a single variable, a tuple of variables or a
    list of variables. The <Xs_type> field must then be a single type, a tuple
    of types of the same length as the tuple of variables or a list of types of
    the same length as the list of variables, respectively. Tuples and lists
    can be combined in any way, as long as <Xs> and <Xs_type> are compatible.
    All the variables inside <Xs> can (and should) be present as free variables
    inside the wrapped property <Prop>. When a ?FORALL wrapper is encountered, a
    random instance of <Xs_type> is produced and each variable in <Xs> is
    replaced inside <Prop> by its corresponding instance.
?IMPLIES(<Precondition>, <Prop>)
    This wrapper only makes sense when in the scope of at least one ?FORALL. The
    <Precondition> field must be a boolean expression or a statement block that
    returns a boolean. If the precondition evaluates to 'false' for the variable
    instances produced in the enclosing ?FORALL wrappers, the test case is
    rejected (it doesn't count as a failing test case), and PropEr starts over
    with a new random test case. Also, in verbose mode, an 'x' is printed on
    screen.
collect(<Category>, <Prop>) or ?COLLECT(<Category>, <Prop>)
    The <Category> field can be an expression or statement block that evaluates
    to any term - the test case produced will be categorized under this term.
    All produced categories are printed at the end of testing (in case no test
    fails) along with the percentage of test cases belonging to each category.
    Multiple 'collect' wrappers are allowed in a single property, in which case
    the percentages for each 'collect' wrapper are printed separately.
?WHENFAIL(<Action>, <Prop>)
    The <Action> field should contain an expression or statement block that
    produces some side-effect (e.g. prints something to the screen). In case
    this test fails, <Action> will be executed. Note that such actions are not
    executed at all when in quiet mode.
?TRAPEXIT(<Prop>)
    Signifies that the code comprising <Prop> may report failure by exiting
    abnormally, e.g. if it spawns and links to a worker thread, the worker
    thread crashes and the parent thread was not trapping exits itself.
?TIMEOUT(<Time_limit>, <Prop>)
    Signifies that <Prop> should be considered failing if it takes more than
    <Time_limit> milliseconds to return. The purpose of this wrapper is to test
    code that may hang if something goes wrong. The <Prop> field cannot contain
    any ?FORALL or ?TIMEOUT macros.

The following predefined properties may be used in place of a simple boolean
expression as the innermost property:

equals(<A>, <B>)
    Returns true if <A> =:= <B>, else returns false and prints "<A> =/= <B>" on
    screen.

Additionally, a property may be wrapped with one or more of the following
outer-level wrappers, which control the behaviour of the testing subsystem:

numtests(<Positive_number>, <Prop>) or ?NUMTESTS(<Positive_number>, <Prop>)
    Specifies the number of tests to run. Default is 100.
fails(<Prop>) or ?FAILS(<Prop>)
    Specifies that we expect the property to fail for some input. The property
    will be considered failing if it passes all the tests.


In verbose mode, each succeeding test prints a '.' on screen. If a test fails,
a '!' is printed and, unless the test was expected to fail, the program attempts
to produce a minimal test case that fails the property in the same way. Note
that failure may also be signified by throwing an exception (but not an error).

For some actual usage examples, see the code in the examples directory. The
testing modules in the tests directory may also be of interest.


--------------------------------------------------------------------------------
Options
--------------------------------------------------------------------------------

Options can be provided as a second argument to proper:check. A single option
can be written stand-alone, or multiple options can be provided in a list. The
available options are:

'quiet'
    Enables quiet mode - nothing is printed on screen, the results of testing
    are returned in a tagged tuple. The return tuple can be one of the
    following:
    * {'passed', <Number_of_tests_passed>, <Testcase_statistics>}
    * {'failed', <After_so_many_tests>, <Failure_reason>, <Failing_testcase>}
    * {'failed', <After_so_many_tests>, <Failure_reason>,
       <Original_failing_testcase>, <Number_of_shrinks>, <Simplified_testcase>}
    * {'error', <Type_of_error>}
'crypto'
    Enables the use of the crypto module for some kinds of random generation
    (namely, the generation of binaries and the generation of ranges of
    integers) - make sure the crypto module is available before enabling this.
    This has the side-effect that an INFO message is printed on screen when
    the program exits, because of the stopping of the crypto server.
    CAUTION: This option is incompatible with the random function generation
    subsystem - do not enable it for tests that contain randomly generated
    functions.
{'numtests', <Positive_number>} or simply <Positive_number>
    This is equivalent to the 'numtests' property wrapper. Any 'numtests'
    wrappers in the actual property will overwrite this setting.
{'max_shrinks', <Non_negative_number>}
    Specifies the maximum number of times a failing test case should be shrunk
    before returning. Note that the shrinking may stop before so many shrinks
    are achieved if the shrinking subsystem deduces that it cannot shrink the
    failing test case further. Default is 300.
{'constraint_tries', <Positive_number>}
    Specifies the maximum number of tries before the generator subsystem gives
    up on producing an instance that satisfies a ?SUCHTHAT constraint. Default
    is 50.
'fails'
    This is equivalent to the 'fails' property wrapper.


--------------------------------------------------------------------------------
Basic types
--------------------------------------------------------------------------------

The following basic types are provided:

* integer() : all integers,
    also written as largeint() for compatibility with QuickCheck,
    the shrinking subsystem will attempt to shrink instances of this type to
    values as close as possible to 0
* integer(Low,High) : integers between 'Low' and 'High', bounds included,
    also written as choose(Low,High) and range(Low,High),
    Low and High must be Erlang expressions that evaluate to integers, with
    Low =< High,
    instances shrink towards the bound with the smallest absolute value
* non_neg_integer() : all non-negative integers,
    instances shrink towards 0
* pos_integer() : all positive integers,
    instances shrink towards 1
* neg_integer() : all negative integers,
    instances shrink towards -1
* float() : all floating point numbers,
    also written as real() for compatibility with QuickCheck,
    instances shrink towards 0.0
* float(Low,High) : all floats between 'Low' and 'High', bounds included,
    Low and High must be Erlang expressions that evaluate to floats, with
    Low =< High,
    instances shrink towards the bound with the smallest absolute value
* number() : all numbers (integers and floats),
    instances shrink towards zero (0 or 0.0)
* byte() : all integers between 0 and 255,
    instances shrink towards 0
* char() : all integers between 0 and 16#10ffff,
    instances shrink towards the NUL character, \000
* binary() : all binaries,
    instances shrink towards the empty binary, <<>>
* bitstring() : all bitstrings,
    instances shrink towards the empty bitstring, <<>>
* atom() : all atoms, except those starting with '$'
    You should not use any atoms starting with a '$', as these may clash
    with atoms used internally by PropEr,
    instances shrink towards the empty atom, ''
* boolean() : the atoms 'true' or 'false',
    also written as bool() for compatibility with QuickCheck,
    instances shrink towards 'false'
* list(ElemType) : all lists containing elements of type ElemType,
    instances shrink towards the empty list, []
* string() : all lists of characters,
    instances shrink towards the empty string, ""
* function(ArgTypes, RetType) : all functions that map instances of ArgTypes
    (ArgTypes must be provided in a list) to instances of RetType,
    the syntax function(Arity, RetType) is also acceptable

All the above have analogues in the built-in types of the Erlang language.

In addition, the following types are provided:

* int() : small integers (bound by the current value of the 'size' parameter -
    see the next section for details),
    instances shrink towards 0
* nat() : small non-negative integers (bound by the current value of the 'size'
    parameter - see the next section for details),
    instances shrink towards 0
* non_neg_float() : all non-negative floats,
    instances shrink towards 0.0
* binary(Len) : all binaries with a byte size of 'Len',
    Len must be an Erlang expression that evaluates to a non-negative integer,
    instances shrink towards binaries of zeroes
* bitstring(Len) : all bitstrings with a bit size of 'Len',
    Len must be an Erlang expression that evaluates to a non-negative integer,
    instances shrink towards bitstrings of zeroes
* tuple(ListOfTypes) : all tuples whose i-th element is an instance of the type
    at index i of ListOfTypes,
    also written simply as a tuple of types
* vector(Len,ElemType) : all lists of length Len containing elements of type
    ElemType,
    Len must be an Erlang expression that evaluates to a non-negative integer
* fixed_list(ListOfTypes) : all lists whose i-th element is an instance of the
    type at index i of ListOfTypes,
    also written simply as ListOfTypes
* orderedlist(ElemType) : all sorted lists containing elements of type ElemType,
    instances shrink towards the empty list, []
* exactly(X) : singleton type consisting only of X,
    X must be an evaluated term,
    also written as return(X) or simply as X
* union(ListOfTypes) : the union of all types in ListOfTypes,
    ListOfTypes can't be empty,
    the random instance generator is equally likely to choose any one of the
    types in ListOfTypes,
    the shrinking subsystem will always try to shrink an instance of a type
    union to an instance of the first type in ListOfTypes, thus you should write
    the simplest case first,
    also written as oneof(ListOfTypes) and elements(ListOfTypes)
* weighted_union(ListOfTypes) : a specialization of union(ListOfTypes) where
    each type in ListOfTypes is assigned a frequency like so: {frequency,type},
    frequencies must be Erlang expressions that evaluate to positive integers,
    types with larger frequencies are more likely to be chosen by the random
    instance generator,
    the shrinking subsystem will ignore the frequencies and try to shrink
    towards the first type in ListOfTypes,
    also written as wunion(ListOfTypes) and frequency(ListOfTypes)
* default(Default, Type) : adds a default value, Default, to Type,
    the default serves as a primary shrinking target for instances, while it is
    also chosen by the random instance generation subsystem half the time
* function[0-4](RetType) : equivalent to function([0-4], RetType), provided for
    compatibility with QuickCheck

As you can see from the above descriptions, types can be combined in tuples or
lists to produce other types, while exact values (such as exact numbers, atoms
or strings) can be combined with types inside such structures, like in this
example of the type of a tagged tuple: {'result', integer()}.


--------------------------------------------------------------------------------
How to construct types
--------------------------------------------------------------------------------

The following macros and functions can be applied to types in order to produce
new ones:

?LET(<Xs>, <Xs_type>, <In>)
    To produce an instance of this type, all appearances of the variables in
    <Xs> inside <In> are replaced by their corresponding values in a randomly
    generated instance of <Xs_type>. It's OK for the <In> part to evaluate to a
    type - in that case, an instance of the inner type is generated recursively.
?SUCHTHAT(<X>, <Type>, <Condition>)
    This produces a specialization of <Type>, which only includes those members
    of <Type> that satisfy the constraint <Condition> - that is, those members
    for which the function 'fun(<X>) -> <Condition> end' returns true. If the
    constraint is very strict - that is, only a small percentage of instances
    of <Type> pass the test - it will take a lot of tries for the instance
    generation subsystem to randomly produce a valid instance of the specialized
    type. This will result in slower testing - testing may even be stopped
    short, in case the 'constraint_tries' limit is reached (see the 'Options'
    section). If this is the case, it would be more appropriate to generate
    valid instances of the specialized type using the ?LET macro.
?SUCHTHATMAYBE(<X>, <Type>, <Condition>)
    Equivalent to the ?SUCHTHAT macro, but the constraint <Condition> is
    considered non-strict: if the 'constraint_tries' limit is reached, the
    generator will just return an instance of <Type> instead of failing,
    even if that instance doesn't satisfy the constraint.
non_empty(<List_type>)
    This is a predefined constraint that can be applied to random-length list
    types (e.g. list() and string()) to ensure that the produced lists are not
    empty.
noshrink(<Type>)
    Creates a new type which is equivalent to <Type>, but whose instances are
    never shrunk by the shrinking subsystem.
?SHRINK(<Generator>, <List_of_alternative_generators>)
    This creates a type whose instances are generated by evaluating the
    statement block <Generator> (this may evaluate to a type, which is generated
    recursively). If an instance of such a type is to be shrunk, the generators
    in <List_of_alternative_generators> are first run to produce hopefully
    simpler instances of the type. Thus, the generators in the second argument
    should be simpler than the default. The simplest ones should be at the front
    of the list, since those are the generators preferred by the shrinking
    subsystem. Like the main <Generator>, the alternatives may also evaluate to
    a type, which is generated recursively.
?LETSHRINK(<List_of_variables>, <List_of_types>, <Generator>)
    This is created by combining a ?LET and a ?SHRINK macro. Instances are
    generated by applying a randomly generated list of values inside <Generator>
    (just like a ?LET, only the variables and types must always be in a list).
    When shrinking instances of such a type, the types inside <List_of_types>
    are first tried in place of the parent type.
?LAZY(<Generator>)
    This construct returns a type whose only purpose is to delay the evaluation
    of <Generator> (<Generator> can return a type, which will be generated
    recursively). Using this, you can simulate the lazy generation of instances:
      stream() -> ?LAZY(frequency([ {1,[]}, {3,[0|stream()]} ])).
    The above type produces lists of zeroes with an average length of 3. Note
    that, had we not enclosed the generator with a ?LAZY macro, the evaluation
    would continue indefinitely, due to the eager evaluation of the Erlang
    language.

The following functions and macros are related to the 'size' parameter, which
controls the maximum size of produced instances. The actual size of a produced
instance is chosen randomly, but can never exceed the value of the 'size'
parameter at the moment of generation. A more accurate definition is the
following: the maximum instance of 'size' S can never be smaller than the
maximum instance of 'size' S-1. The actual size of an instance is measured
differently for each type: the actual size of a list is its length, while the
actual size of a tree may be the number of its internal nodes. Some types, e.g.
unions, have no notion of size, thus their generation is not influenced by the
value of 'size'. The 'size' parameter starts at 0 and grows automatically during
testing.

?SIZED(<S>, <Generator>)
    Creates a new type, whose instances are produced by replacing all
    appearances of the <S> parameter inside the statement block <Generator> with
    the value of the 'size' parameter. It's OK for the <Generator> to return a
    type - in that case, an instance of the inner type is generated recursively.
resize(<New_size>, <Type>)
    Overrides the 'size' parameter used when generating instances of <Type> with
    <New_size>. Has no effect on size-less types, such as unions. Also, this
    will not affect the generation of any internal types contained in <Type>,
    such as the elements of a list - those will still be generated using the
    test-wide value of 'size'. One use of this function is to modify types to
    grow faster or slower, like so:
      ?SIZED(Size, resize(Size * 2, list(integer()))
    The above specifies a list type that grows twice as fast as normal lists.
relimit(<New_limit>, <Type>)
    Most sized types have a 'size_limit' parameter, which specifies a maximum to
    the value of 'size' used when generating instances of the type. Lists, for
    example, have a size limit of 200. Using this function, you can specify a
    new such limit for a type. Has no effect on size-less types, such as unions.


--------------------------------------------------------------------------------
Symbolic datatypes
--------------------------------------------------------------------------------

Coming soon.


--------------------------------------------------------------------------------
How to define your own opaque types
--------------------------------------------------------------------------------

Coming soon.


--------------------------------------------------------------------------------
Errors
--------------------------------------------------------------------------------

The following errors may be encountered during testing. The terms provided here
are the error types returned if quiet mode is active - in verbose mode, a
message is printed on screen describing the error.

* 'cant_generate': The instance generation subsystem has failed to produce an
  instance that satisfies some ?SUCHTHAT constraint. You should either increase
  the 'constraint_tries' limit, loosen the failing constraint, or make it
  non-strict.
* 'cant_satisfy': All the tests were rejected because no produced test case
  would pass all ?IMPLIES checks. You should loosen the failing ?IMPLIES
  constraint(s).
* {'unexpected', <Result>}: A test returned an unexpected result. If you ever
  get this error, it means that you have probably found a bug in PropEr
  - please send an error report to the maintainers and remember to include
  both the failing test case and the output of the program, if possible.
