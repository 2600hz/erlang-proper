--------------------------------------------------------------------------------
Contact information and license
--------------------------------------------------------------------------------

PropEr (PROPerty-based testing tool for ERlang) is an open-source implementation
of QuickCheck for Erlang developed by Manolis Papadakis (manopapad@gmail.com)
and Kostis Sagonas (kostis@cs.ntua.gr).

Most of the source code of PropEr is written mainly by Manolis Papadakis.

Copyright 2010 by Manolis Papadakis and Kostis Sagonas.

This program is distributed under the GPL, version 3 or later. Please see the
COPYING file for details.


--------------------------------------------------------------------------------
Quickstart guide
--------------------------------------------------------------------------------

* Compile PropEr: run 'make' (or 'make all', if you also want to build the
  documentation).
* Add PropEr's base directory to your ERL_LIBS environment variable - An easy
  way to do this is to add the following line to your ~/.bashrc file:
     export ERL_LIBS=~/path/to/proper
* Add the following include line to all source files containing properties you
  wish to test:
     -include_lib("proper/include/proper.hrl").
  By including this header, all the macros, types and functions described in
  this file are automatically imported, so you can use them without a module
  identifier. Also, all functions of arity 0 whose name starts with "prop_" are
  automatically exported from the module. If you wish to disable the automatic
  exporting of properties, compile your module with -DPROPER_NOTRANS.
* Compile your source files.
* For each property, run:
     proper:check(your_module:some_property()).
       or
     proper:check(your_module:some_property(), <option/options>).
  You can also try out the random instance generation subsystem by running:
     proper_gen:pick(some_type()).
       or
     proper_gen:pick(some_type(), <size>).

Note to users of Erlang r13b03 or older:

PropEr makes heavy use of recursive types, which are unsupported in versions of
the Erlang/OTP distribution prior to r13b04. To compile PropEr under such a
system, run 'make' like so:
   make NOTYPES=1
This enables the spec+type-stripping parse transform included in PropEr, which
fixes the problem by stripping all type information from PropEr's source files
while compiling.


--------------------------------------------------------------------------------
Introduction
--------------------------------------------------------------------------------

Traditional testing methodologies essentially involve software testers writing a
series of test inputs for their programs, along with their corresponding
expected outputs, then running the program with these inputs and observing
whether it behaves as expected. This method of testing, while simple and easy to
automate, suffers from a few problems, such as:
* Writing test cases by hand is tedious and time consuming.
* It is hard to know whether the test suite covers all aspects of the software
  under test.

Property-based testing is a novel approach to software testing, where the tester
needs only specify the generic structure of valid inputs for the program under
test, plus certain properties (regarding the program's behaviour and the input-
output relation) which are expected to hold for every valid input. A property-
based testing tool, when supplied with this information, should randomly
produce progressively more complex valid inputs, then apply those inputs to the
program while monitoring its execution, to ensure that it behaves according to
its specification, as outlined in the supplied properties.

Here are a few examples of simple properties a user may wish to test, expressed
in natural language:
* The program should accept any character string and convert all lowercase
  letters inside the string to uppercase.
* The program should accept any list of integers. If the input list is at least
  4 elements long, the program should return the 4th largest integer in the
  list, else it should throw an exception.

PropEr is such a property-based testing tool, designed to test programs written
in the Erlang programming language. Its focus is on testing the behaviour of
pure functions. The input domain of functions is specified through the use of
a type system, modeled closely after the type system of the language itself
(see the following sections for details). Properties are written using Erlang
expressions, with the help of a few predefined macros. Work is currently under
way to provide tighter integration with Erlang's built-in type system.


--------------------------------------------------------------------------------
How to write properties (test case generators)
--------------------------------------------------------------------------------

The simplest properties that PropEr can test consist of a single boolean
expression (or a statement block that returns a boolean), which is expected to
evaluate to 'true'. Thus, the test 'true' always succeeds, while the test
'false' always fails. More complex (and useful) properties can be written by
wrapping such a boolean expression with one or more of the following wrappers:

?FORALL(<Xs>, <Xs_type>, <Prop>)
    The <Xs> field can either be a single variable, a tuple of variables or a
    list of variables. The <Xs_type> field must then be a single type, a tuple
    of types of the same length as the tuple of variables or a list of types of
    the same length as the list of variables, respectively. Tuples and lists can
    be combined in any way, as long as <Xs> and <Xs_type> are compatible. Both
    PropEr-provided types (as listed in the 'Basic types' and 'How to construct
    types' sections) and types declared in Erlang's built-in typesystem (we
    refer to such types in this README as 'native types') may be used in the
    <Xs_type> field. The use of native types in ?FORALLs is subject to some
    limitations, as described in the 'Native types support' section. All the
    variables inside <Xs> can (and should) be present as free variables inside
    the wrapped property <Prop>. When a ?FORALL wrapper is encountered, a random
    instance of <Xs_type> is produced and each variable in <Xs> is replaced
    inside <Prop> by its corresponding instance.
?IMPLIES(<Precondition>, <Prop>)
    This wrapper only makes sense when in the scope of at least one ?FORALL. The
    <Precondition> field must be a boolean expression or a statement block that
    returns a boolean. If the precondition evaluates to 'false' for the variable
    instances produced in the enclosing ?FORALL wrappers, the test case is
    rejected (it doesn't count as a failing test case), and PropEr starts over
    with a new random test case. Also, in verbose mode, an 'x' is printed on
    screen.
collect(<Category>, <Prop>)
    The <Category> field can be an expression or statement block that evaluates
    to any term - the test case produced will be categorized under this term.
    All produced categories are printed at the end of testing (in case no test
    fails) along with the percentage of test cases belonging to each category.
    Multiple 'collect' wrappers are allowed in a single property, in which case
    the percentages for each 'collect' wrapper are printed separately.
collect(<Stats_printer>, <Category>, <Prop>)
    Same as collect/2, but takes an extra first argument, which should be a fun
    with one of the following signatures:
    (SortedSample :: [term()]) -> 'ok'
    (SortedSample :: [term()], TestsPassed :: pos_integer()) -> 'ok'
    This fun will be called at the end of testing (in case no test fails) with
    a sorted list of collected terms and, in the case of the 2-argument variant,
    the number of tests that actually succeeded. It is expected to print some
    statistics over the collected terms. with_title/1 is a predefined function
    that accepts an atom or string and returns a stats printing function which
    is equivalent to the default one, but prints the given title above the
    statistics.
aggregate(<Categories>, <Prop>)
    Same as collect/2, but accepts a list of categories under which to classify
    the produced test case.
aggregate(<Stats_printer>, <Categories>, <Prop>)
    Same as collect/3, but accepts a list of categories under which to classify
    the produced test case.
measure(<Title>, <Number> | <List_of_numbers>, <Prop>)
    The number (or numbers) provided are collected and some numeric statistics
    over the collected sample are printed at the end of testing (in case no test
    fails), prepended with <Title>, which should be an atom or string.
?WHENFAIL(<Action>, <Prop>)
    The <Action> field should contain an expression or statement block that
    produces some side-effect (e.g. prints something to the screen). In case
    this test fails, <Action> will be executed. Note that the output of such
    actions is not affected by the verbosity setting of the main application.
?TIMEOUT(<Time_limit>, <Prop>)
    Signifies that <Prop> should be considered failing if it takes more than
    <Time_limit> milliseconds to return. The purpose of this wrapper is to test
    code that may hang if something goes wrong. This cannot contain any more
    wrappers.

The following predefined properties may be used in place of a simple boolean
expression as the innermost property:

equals(<A>, <B>)
    Returns true if <A> =:= <B>, else returns false and prints "<A> =/= <B>" on
    screen.

Additionally, a property may be wrapped with one or more of the following
outer-level wrappers, which control the behaviour of the testing subsystem. If
the same wrapper appears more than once in a property, the innermost takes
precedence.

numtests(<Positive_number>, <Prop>)
    Specifies the number of tests to run. Default is 100.
fails(<Prop>)
    Specifies that we expect the property to fail for some input. The property
    will be considered failing if it passes all the tests.
on_output(<Output_function>, <Prop>)
    Specifies an output function to be used by PropEr for all output printing.
    This wrapper is equivalent to the 'on_output' option (see the 'Options'
    section for details).

Note that failure of a property may also be signified by throwing an exception,
error or exit.

For some actual usage examples, see the code in the examples directory. The
testing modules in the tests directory may also be of interest.


--------------------------------------------------------------------------------
Program behaviour
--------------------------------------------------------------------------------

When running in verbose mode (this is the default), each succeeding test prints
a '.' on screen. If a test fails, a '!' is printed, along with the failing
test case (the instances of the types in every ?FORALL) and the cause of the
failure, if it was not simply the falsification of the property. Then, unless
the test was expected to fail, PropEr attempts to produce a minimal test case
that fails the property in the same way. This process is called
'shrinking'. During shrinking, a '.' is printed for each successful
simplification of the failing test case. When PropEr reaches its shrinking limit
or realizes that the instance cannot be shrunk further while still failing the
test, it prints the minimal failing test case and failure reason and exits.

The return value of PropEr can be one of the following:

* 'true': The property held for all valid produced inputs.
* 'false': The property failed for some input.
* {'error', <Type_of_error>}: An error occured - see the 'Errors' section for a
  description of possible errors.

In long-result mode (see the 'Options' section), a tagged tuple is returned,
detailing the results of testing. The return tuple can be one of the following:

* {'passed', <Number_of_tests_passed>, <List_of_categories_lists>}: The property
  held for all <Number_of_tests_passed> valid produced inputs. The third element
  of the return tuple is a list containing one list of collected categories for
  each separate 'collect' or 'aggregate' clause in the test property.
* {'failed', <After_so_many_tests>, <Original_counterexample>,
   <Number_of_shrinks>, <Simplified_counterexample>}: The property failed for
  the input contained in <Original_counterexample>, which has been shrunk to the
  minimal failing input contained in <Simplified_counterexample> (see the
  'Counterexamples' section). Note that <Number_of_shrinks> will always be zero
  if PropEr had been instructed not to attempt shrinking on this input.
* {'error', <Type_of_error>}: An error occured - see the 'Errors' section for a
  description of possible errors.

You can also run PropEr in pure mode by using proper:pure_check/1,2 instead of
proper:check/1,2. Under this mode, PropEr will perform no I/O and will not
access the caller's process dictionary in any way. Please note that PropEr will
not actually run as a pure function under this mode.

To test all properties exported from a module (a property is a 0-arity function
whose name begins with "prop_"), you can run:
   proper:module(<Module>).
     or
   proper:module(<Module>, <option/options>).
This returns a list of all failing and faulty properties, in the form of mfas.
Testing progress is also printed on screen (unless 'quiet' mode is active). The
provided options are passed on to each property, except for 'long_result', which
controls the return value format of proper:module itself: under 'long_result'
mode, a list of {mfa(),counterexample()} tuples is returned.


--------------------------------------------------------------------------------
Counterexamples
--------------------------------------------------------------------------------

The last (simplest) counterexample produced by PropEr during a testing run can
be retrieved after testing has finished, by running proper:get_counterexample().
When testing a whole module, run proper:get_counterexamples() to get a
counterexample for each failing property. To enable this functionality, some
information has to remain in the process dictionary even after PropEr has
returned. To completely clean up the process dictionary of PropEr-produced
entries, run proper:clean_garbage(). Counterexamples can also be retrieved by
running PropEr in long-result mode, where counterexamples are also returned as
part of the return value.

You can re-check a specific counterexample <CExm> against the property <Prop>
that it previously falsified by running:
   proper:retest(<Prop>, <CExm>)
     or
   proper:retest(<Prop>, <CExm>, <option/options>)
This will return one of the following:
  * 'true': The property now holds for this test case.
  * 'false': The test case still fails (although not necessarily for the same
    reason as before).
  * {'error', <Type_of_error>}: An error occured - see the 'Errors' section for
    a description of possible errors.
Unless a 'no_shrink' option is present, proper:retest will also try to shrink
the counterexample. The minimal counterexample can again be retrieved by running
proper:get_counterexample(). Unless silent mode is active, PropEr will also
print a message on screen, describing the result of the re-checking.

In long-result mode, the return value format of proper:retest becomes:
  * 'passed': The test case passed the property.
  * {'failed', <Number_of_Shrinks>, <Minimal_CExm>}: The property still fails
    for this input. After <Number_of_Shrinks> shrinks, PropEr simplified the
    counterexample to <Minimal_CExm>.
  * {'error', <Type_of_error>}: An error occured - see the 'Errors' section for
    a description of possible errors.

Apart from the actual produced instances of the types in ?FORALL wrappers, a
counterexample contains some additional information that PropEr needs in order
to re-check a failing test case. Use the following functions to extract the
useful parts of a counterexample:
* proper:get_bound/1: Extracts the actual test case (produced instances of types
  in ?FORALLs).
* proper:get_fail_reason/1: Extracts a term representing the cause of failure.
  Possible failure reasons are:
  - 'false_prop': The property evaluates to 'false' for this test case.
  - 'timeout': Evaluation of the property exceeded the time limit specified in
    a ?TIMEOUT clause.
  - {'exception',<Kind>,<Reason>,<Stacktrace>}: A <Kind>:<Reason> exception
    was thrown by the property evaluation code.


--------------------------------------------------------------------------------
Options
--------------------------------------------------------------------------------

Options can be provided as an extra argument to testing functions exported from
the main proper module (such as proper:check). A single option  can be written
stand-alone, or multiple options can be provided in a list. Unrecognized options
are ignored. When two settings conflict, the one that comes first in the list
takes precedence. Settings given inside extrernal wrappers to a property (see
the 'How to write properties' section) override any conflicting settings
provided as options.

The available options are:

'quiet'
    Enables quiet mode - no output is printed on screen while PropEr is running.
{'to_file', <IO_device>}
    Redirects all of PropEr's output to <IO_device>, which should be an IO
    device associated with a file opened for writing.
{'on_output', <output_function>}
    PropEr will use the supplied function for all output printing. This function
    should accept two arguments in the style of io:format/2.
    CAUTION: The above three output control options are incompatible with each
    other.
'long_result'
    Enables long-result mode (see the 'Program behaviour' section for details).
'crypto'
    Enables the use of the crypto module for some kinds of random generation
    (namely, the generation of binaries and the generation of ranges of
    integers) - make sure the crypto module is available before enabling this.
    This has the side-effect that an INFO message is printed on screen when
    the program exits, because of the stopping of the crypto server.
    CAUTION: This option is incompatible with the random function generation
    subsystem - do not enable it for tests that contain randomly generated
    functions.
{'numtests', <Positive_number>} or simply <Positive_number>
    This is equivalent to the 'numtests' property wrapper. Any 'numtests'
    wrappers in the actual property will overwrite this setting.
{'start_size', <Size>}
    Specifies the initial value of the 'size' parameter (default is 1), see the
    'Basic types' section for details.
{'max_shrinks', <Non_negative_number>}
    Specifies the maximum number of times a failing test case should be shrunk
    before returning. Note that the shrinking may stop before so many shrinks
    are achieved if the shrinking subsystem deduces that it cannot shrink the
    failing test case further. Default is 500.
'noshrink'
    Instructs PropEr to not attempt to shrink any failing test cases.
{'constraint_tries', <Positive_number>}
    Specifies the maximum number of tries before the generator subsystem gives
    up on producing an instance that satisfies a ?SUCHTHAT constraint. Default
    is 50.
'fails'
    This is equivalent to the 'fails' property wrapper.
{'spec_timeout', 'infinity' | <Non_negative_number>}
    When testing a spec, PropEr will consider an input to be failing if the
    function under test takes more that the specified amount of milliseconds to
    return for that input.


--------------------------------------------------------------------------------
Basic types
--------------------------------------------------------------------------------

The following basic types are provided:

* integer() : all integers,
    also written as largeint() for compatibility with QuickCheck,
    the shrinking subsystem will attempt to shrink instances of this type to
    values as close as possible to 0
* integer(Low,High) : integers between 'Low' and 'High', bounds included,
    also written as choose(Low,High) and range(Low,High),
    Low and High must be Erlang expressions that evaluate to integers, with
    Low =< High,
    instances shrink towards the bound with the smallest absolute value
* non_neg_integer() : all non-negative integers,
    instances shrink towards 0
* pos_integer() : all positive integers,
    instances shrink towards 1
* neg_integer() : all negative integers,
    instances shrink towards -1
* float() : all floating point numbers,
    also written as real() for compatibility with QuickCheck,
    instances shrink towards 0.0
* float(Low,High) : all floats between 'Low' and 'High', bounds included,
    Low and High must be Erlang expressions that evaluate to floats, with
    Low =< High,
    instances shrink towards the bound with the smallest absolute value
* number() : all numbers (integers and floats),
    instances shrink towards zero (0 or 0.0)
* byte() : all integers between 0 and 255,
    instances shrink towards 0
* char() : all integers between 0 and 16#10ffff,
    instances shrink towards the NUL character, \000
* binary() : all binaries,
    instances shrink towards the empty binary, <<>>
* bitstring() : all bitstrings,
    instances shrink towards the empty bitstring, <<>>
* atom() : all atoms, except those starting with '$'
    you should not use any atoms starting with a '$', as these may clash
    with atoms used internally by PropEr,
    instances shrink towards the empty atom, ''
* boolean() : the atoms 'true' or 'false',
    also written as bool() for compatibility with QuickCheck,
    instances shrink towards 'false'
* list(ElemType) : all lists containing elements of type ElemType,
    instances shrink towards the empty list, []
* list() : equivalent to list(any())
* string() : all lists of characters,
    instances shrink towards the empty string, ""
* function(ArgTypes, RetType) : all pure functions that map instances of
    ArgTypes (ArgTypes must be provided in a list) to instances of RetType,
    the syntax function(Arity, RetType) is also acceptable
* any() : all Erlang terms (that PropEr can produce)
    also written as term()
    currently, functions are never produced as instances of any()

All the above have analogues in the built-in types of the Erlang language.

In addition, the following types are provided:

* int() : small integers (bound by the current value of the 'size' parameter -
    see the next section for details),
    instances shrink towards 0
* nat() : small non-negative integers (bound by the current value of the 'size'
    parameter - see the next section for details),
    instances shrink towards 0
* non_neg_float() : all non-negative floats,
    instances shrink towards 0.0
* binary(Len) : all binaries with a byte size of 'Len',
    Len must be an Erlang expression that evaluates to a non-negative integer,
    instances shrink towards binaries of zeroes
* bitstring(Len) : all bitstrings with a bit size of 'Len',
    Len must be an Erlang expression that evaluates to a non-negative integer,
    instances shrink towards bitstrings of zeroes
* tuple(ListOfTypes) : all tuples whose i-th element is an instance of the type
    at index i of ListOfTypes,
    also written simply as a tuple of types
* loose_tuple(ElemType) : all tuples whose elements are all of type ElemType
    instances shrink towards {}
* tuple() : equivalent to loose_tuple(any())
* vector(Len,ElemType) : all lists of length Len containing elements of type
    ElemType,
    Len must be an Erlang expression that evaluates to a non-negative integer
* fixed_list(ListOfTypes) : all lists whose i-th element is an instance of the
    type at index i of ListOfTypes,
    also written simply as ListOfTypes
* orderedlist(ElemType) : all sorted lists containing elements of type ElemType,
    instances shrink towards the empty list, []
* exactly(X) : singleton type consisting only of X,
    X must be an evaluated term,
    also written as return(X) or simply as X
* union(ListOfTypes) : the union of all types in ListOfTypes,
    ListOfTypes can't be empty,
    the random instance generator is equally likely to choose any one of the
    types in ListOfTypes,
    the shrinking subsystem will always try to shrink an instance of a type
    union to an instance of the first type in ListOfTypes, thus you should write
    the simplest case first,
    also written as oneof(ListOfTypes) and elements(ListOfTypes)
* weighted_union(ListOfTypes) : a specialization of union(ListOfTypes) where
    each type in ListOfTypes is assigned a frequency like so: {frequency,type},
    frequencies must be Erlang expressions that evaluate to positive integers,
    types with larger frequencies are more likely to be chosen by the random
    instance generator,
    the shrinking subsystem will ignore the frequencies and try to shrink
    towards the first type in ListOfTypes,
    also written as wunion(ListOfTypes) and frequency(ListOfTypes)
* default(Default, Type) : adds a default value, Default, to Type,
    the default serves as a primary shrinking target for instances, while it is
    also chosen by the random instance generation subsystem half the time
* function[0-4](RetType) : equivalent to function([0-4], RetType), provided for
    compatibility with QuickCheck
* timeout() : equivalent to union([non_neg_integer() | 'timeout']),
    instances shrink towards 0
* arity() : equivalent to range(0,255),
    instances shrink towards 0

As you can see from the above descriptions, types can be combined in tuples or
lists to produce other types, while exact values (such as exact numbers, atoms
or strings) can be combined with types inside such structures, like in this
example of the type of a tagged tuple: {'result', integer()}.


--------------------------------------------------------------------------------
How to construct types
--------------------------------------------------------------------------------

The following macros and functions can be applied to types in order to produce
new ones:

?LET(<Xs>, <Xs_type>, <In>)
    To produce an instance of this type, all appearances of the variables in
    <Xs> inside <In> are replaced by their corresponding values in a randomly
    generated instance of <Xs_type>. It's OK for the <In> part to evaluate to a
    type - in that case, an instance of the inner type is generated recursively.
?SUCHTHAT(<X>, <Type>, <Condition>)
    This produces a specialization of <Type>, which only includes those members
    of <Type> that satisfy the constraint <Condition> - that is, those members
    for which the function 'fun(<X>) -> <Condition> end' returns 'true'. If the
    constraint is very strict - that is, only a small percentage of instances
    of <Type> pass the test - it will take a lot of tries for the instance
    generation subsystem to randomly produce a valid instance of the specialized
    type. This will result in slower testing - testing may even be stopped
    short, in case the 'constraint_tries' limit is reached (see the 'Options'
    section). If this is the case, it would be more appropriate to generate
    valid instances of the specialized type using the ?LET macro. Also make sure
    that even small instances can satisfy the constraint, since PropEr will only
    try small instances at the start of testing. If this is not possible, you
    can instruct PropEr to start at a larger size ('start_size' option - see the
    'Options' section for details).
?SUCHTHATMAYBE(<X>, <Type>, <Condition>)
    Equivalent to the ?SUCHTHAT macro, but the constraint <Condition> is
    considered non-strict: if the 'constraint_tries' limit is reached, the
    generator will just return an instance of <Type> instead of failing,
    even if that instance doesn't satisfy the constraint.
non_empty(<List_type>)
    This is a predefined constraint that can be applied to random-length list
    types (e.g. list() and string()) to ensure that the produced lists are not
    empty.
noshrink(<Type>)
    Creates a new type which is equivalent to <Type>, but whose instances are
    never shrunk by the shrinking subsystem.
?SHRINK(<Generator>, <List_of_alternative_generators>)
    This creates a type whose instances are generated by evaluating the
    statement block <Generator> (this may evaluate to a type, which is generated
    recursively). If an instance of such a type is to be shrunk, the generators
    in <List_of_alternative_generators> are first run to produce hopefully
    simpler instances of the type. Thus, the generators in the second argument
    should be simpler than the default. The simplest ones should be at the front
    of the list, since those are the generators preferred by the shrinking
    subsystem. Like the main <Generator>, the alternatives may also evaluate to
    a type, which is generated recursively.
?LETSHRINK(<List_of_variables>, <List_of_types>, <Generator>)
    This is created by combining a ?LET and a ?SHRINK macro. Instances are
    generated by applying a randomly generated list of values inside <Generator>
    (just like a ?LET, with the added constraint that the variables and types
    must be provided in a list - alternatively, <List_of_types> may be a list or
    vector type). When shrinking instances of such a type, the sub-instances
    that were combined to produce it are first tried in place of the failing
    instance.
?LAZY(<Generator>)
    This construct returns a type whose only purpose is to delay the evaluation
    of <Generator> (<Generator> can return a type, which will be generated
    recursively). Using this, you can simulate the lazy generation of instances:
      stream() -> ?LAZY(frequency([ {1,[]}, {3,[0|stream()]} ])).
    The above type produces lists of zeroes with an average length of 3. Note
    that, had we not enclosed the generator with a ?LAZY macro, the evaluation
    would continue indefinitely, due to the eager evaluation of the Erlang
    language.

The following functions and macros are related to the 'size' parameter, which
controls the maximum size of produced instances. The actual size of a produced
instance is chosen randomly, but can never exceed the value of the 'size'
parameter at the moment of generation. A more accurate definition is the
following: the maximum instance of 'size' S can never be smaller than the
maximum instance of 'size' S-1. The actual size of an instance is measured
differently for each type: the actual size of a list is its length, while the
actual size of a tree may be the number of its internal nodes. Some types, e.g.
unions, have no notion of size, thus their generation is not influenced by the
value of 'size'. The 'size' parameter starts at 0 and grows automatically during
testing.

?SIZED(<S>, <Generator>)
    Creates a new type, whose instances are produced by replacing all
    appearances of the <S> parameter inside the statement block <Generator> with
    the value of the 'size' parameter. It's OK for the <Generator> to return a
    type - in that case, an instance of the inner type is generated recursively.
resize(<New_size>, <Type>)
    Overrides the 'size' parameter used when generating instances of <Type> with
    <New_size>. Has no effect on size-less types, such as unions. Also, this
    will not affect the generation of any internal types contained in <Type>,
    such as the elements of a list - those will still be generated using the
    test-wide value of 'size'. One use of this function is to modify types to
    grow faster or slower, like so:
      ?SIZED(Size, resize(Size * 2, list(integer()))
    The above specifies a list type that grows twice as fast as normal lists.


--------------------------------------------------------------------------------
Native types support
--------------------------------------------------------------------------------

PropEr can parse types expressed in Erlang's native type format and convert them
to its own type format. Such expressions can be used instead of regular type
constructors in the second argument of ?FORALLs. No extra notation is required -
PropEr will detect which calls correspond to native types by applying a parse
transform during compilation. This parse transform is automatically applied to
any module that includes the proper.hrl header file. You can disable this
feature by compiling your modules with -DPROPER_NOTRANS. Note that this will
currently also disable the automatic exporting of properties.

The use of native types in properties is subject to the following usage rules:

* Native types cannot be used outside of ?FORALLs.
* Inside ?FORALLs, native types can be combined with other native types, and
  even with PropEr types, inside tuples and lists (the constructs '[...]',
  '{...}' and '++' are all allowed).
* All other constructs of Erlang's built-in type system (e.g. '|' for union, '_'
  as an alias of 'any()', '<<_:_>>' binary type syntax or 'fun((...) -> ...)'
  function type syntax) are not allowed in ?FORALLs, since they are rejected by
  the Erlang parser.
* Anything other than a tuple constructor, list constructor, '++' application,
  local or remote call will automatically be considered a PropEr type
  constructor and not be processed further by the parse transform.
* Parametric native types are fully supported - of course, they can only appear
  instantiated in a ?FORALL. The arguments of parametric native types are always
  interpreted as native types.
* Parametric PropEr types, on the other hand, can take any kind of argument. You
  can even mix native and PropEr types in the arguments of a PropEr type. For
  example, assuming that the following declarations are present:
     my_proper_type() -> ?LET(...).
     -type my_native_type() :: ... .
  Then the following expressions are all legal:
     vector(2, my_native_type())
     function(0, my_native_type())
     union([my_proper_type(), my_native_type()])
* Some type constructors can take native types as arguments (but only inside
  ?FORALLs):
  - ?SUCHTHAT, ?SUCHTHATMAYBE, non_empty, noshrink: these work with native
    types too
  - ?LAZY, ?SHRINK, resize, ?SIZED: these don't work with native types
  - ?LET, ?LETSHRINK: only the top-level base type can be a native type
* Native type declarations in the ?FORALLs of a module can reference any custom
  type declared in a -type or -opaque attribute of the same module, as long as
  no module identifier is used.
* Typed records cannot be referenced inside ?FORALLs using the '#rec_name{}'
  syntax. To use a typed record in a ?FORALL, enclose the record in a custom
  type like so:
     -type rec_name() :: #rec_name{}.
  and use the custom type instead.
* ?FORALLs may contain references to self-recursive or mutually recursive native
  types, so long as each type in the hierarchy has a clear base case. Currently,
  PropEr requires that the toplevel of any recursive type declaration is either
  a (maybe empty) list or a union containing at least one choice that doesn't
  reference the type (it may, however, reference any of the types that are
  mutually recursive with it). This means, for example, that some valid
  recursive type declarations, such as this one:
     ?FORALL(..., a(), ...) where:
     -type a() :: {'a','none' | a()}.
  are not accepted by PropEr. However, such types can be rewritten in a way that
  allows PropEr to parse them:
     ?FORALL(..., a(), ...) where:
     -type a() :: {'a','none'} | {'a',a()}.
  This also means that recursive record declarations are not allowed:
    ?FORALL(..., rec(), ...) where:
     -type rec() :: #rec{}.
     -record(rec, {a = 0 :: integer(), b = 'nil' :: 'nil' | #rec{}}).
  A little rewritting can usually remedy this problem as well:
     ?FORALL(..., rec(), ...) where:
     -type rec() :: #rec{b :: 'nil'} | #rec{b :: rec()}.
     -record(rec, {a = 0 :: integer(), b = 'nil' :: 'nil' | #rec{}}).
* Remote types may be referenced in a ?FORALL, as long as they are exported from
  the remote module. Currently, PropEr requires that any modules whose types are
  remotely referenced from within properties are present in the code path at
  compile time, either compiled with debug_info enabled, or only in source form.
  If PropEr cannot find a remote module, cannot get the abstract code from the
  compiled object file or fails to compile the source file, all calls to that
  module will automatically be considered calls to PropEr type constructors.
* For native types to be translated correctly, both the module that contains the
  ?FORALL declaration as well as any module that contains the declaration of a
  type referenced (directly or indirectly) from inside a ?FORALL must be present
  in the code path at runtime, either compiled with debug_info enabled or only
  in source form.
* Local types with the same name as an auto-imported BIF are not accepted by
  PropEr, unless the BIF in question has been declared in a no_auto_import
  option.
* When an expression can be interpreted both as a PropEr type and as a native
  type, the former takes precedence. This means that a function foo() will
  shadow a type foo() if they are both present in the module. The same rule
  applies to remote functions and types as well.
* The above may cause some confusion when list syntax is used:
  - The expression '[integer()]' can be interpreted both ways, so the PropEr way
    applies. Therefore, instances of this type will always be lists of length 1,
    not arbitrary integer lists, as would be expected when interpreting the
    expression as a native type.
  - Assuming that a custom type foo/1 has been declared, the expression
    foo([integer()]) can only be interpreted as a native type declaration,
    which means that the generic type of integer lists will be passed to foo/1.
* Currently, PropEr does not detect the following mistakes:
  - inline record-field specializations that reference non-existent fields
  - type parameters that are not present in the RHS of a '-type' declaration
  - using '_' as a type variable in the LHS of a '-type' declaration
  - using the same variable in more than one position in the LHS of a '-type'
    declaration


--------------------------------------------------------------------------------
Spec testing
--------------------------------------------------------------------------------

You can test the accuracy of an exported function's spec by running:
     proper:check_spec(mfa()).
       or
     proper:check_spec(mfa(), <option/options>).
Under this mode of operation, PropEr will call the provided function with
increasingly complex valid inputs (according to its spec) and test that no
unexpected value is returned. If an input is found that violates the spec, it
will be saved as a counterexample and PropEr will attempt to shrink it. You can
re-check a counterexample against the spec that it violated by running:
     proper:retest_spec(mfa(), <CExm>).
       or
     proper:retest_spec(mfa(), <CExm>, <option/options>).
You can test all exported functions of a module against their spec by running:
     proper:module_specs(<Module>).
       or
     proper:module_specs(<Module>, <option/options/).
The behaviour of proper:module_specs is similar to that of proper:module.

The use of check_spec is subject to the following usage rules:

* Currently, PropEr can't test functions whose range contains a type that
  exhibits a certain kind of self-reference: it is (directly or indirectly)
  self-recursive and at least one recursion path contains only unions and type
  references. E.g. these types are acceptable:
     -type a(T) :: T | {'bar',a(T)}.
     -type b() :: 42 | [c()].
     -type c() :: {'baz',b()}.
  while these are not:
     -type a() :: 'foo' | b().
     -type b() :: c() | [integer()].
     -type c() :: 'bar' | a().
     -type d(T) :: T | d({'baz',T}).
* Throwing any exception or raising an 'error:badarg' is considered normal
  behaviour.
* Only the first clause of the function's spec is considered.
* The only spec constraints we accept are 'is_subtype' constraints whose first
  argument is a simple, non-'_' variable. It is not checked whether or not these
  variables actually appear in the spec. The second argument of an 'is_subtype'
  constraint cannot contain any non-'_' variables. Multiple constraints for the
  same variable are not supported.


--------------------------------------------------------------------------------
Symbolic datatypes
--------------------------------------------------------------------------------

When writing properties that involve abstract data types, such as dicts or sets,
it is usually best to avoid dealing with the ADTs' internal representations
directly. Working, instead, with a symbolic representation of an ADT's
construction process (series of API calls) has several benefits:

* Failing testcases are easier to read and understand. Compare:
     {call,sets,from_list,[[1,2,3]]}
  with:
     {set,3,16,16,8,80,48,
	  {[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]},
	  {{[],[3],[],[],[],[],[2],[],[],[],[],[1],[],[],[],[]}}}
* Failing testcases are easier to shrink.
* It is especially useful when testing the datatype itself: Certain
  implementation errors may depend on some particular selection and ordering of
  API calls, thus it is important to cover the entire ADT construction API.

PropEr supports the symbolic representation of datatypes, using the following
syntax:

* {call,<Module>,<Function>,<Arguments>}: This represents a call to the API
  function <Module>:<Function> with arguments <Arguments>. Each of the arguments
  may be a symbolic call itself or contain other symbolic calls in lists or
  tuples of arbitrary depth.
* {'$call',<Module>,<Function>,<Arguments>}: Identical to the above, but gets
  evaluated automatically before being applied to a property.
* {var,<Atom>}: This contruct serves as a placeholder for values that are not
  known at type construction time. It will be replaced by the actual value of
  the variable during evaluation.

The following functions, automatically imported from the proper_symb module, can
be used when working with symbolic instances:

* eval(<Symbolic_instance>): Intended for use inside the property-testing code,
  this function evaluates a symbolic instance.
* eval(<VarValues>, <Symbolic_instance>): Same as above, but accepts a proplist
  of variable names and values, to be replaced anywhere inside the symbolic
  instance before proceeding with the evaluation.
* defined(<Symbolic_instance>): Returns true if the symbolic instance can be
  successfully evaluated (its evaluation doesn't raise an error or exception).
* well_defined(<Symbolic_instance>): An attribute which can be applied to
  symbolic generators that may produce invalid sequences of operations when
  called. The resulting type is guaranteed to only produce well-defined symbolic
  instances.
* pretty_print/1,2: Similar in calling convention to eval/1,2, but returns a
  string representation of the call sequence instead of evaluating it.


--------------------------------------------------------------------------------
Auto-ADT
--------------------------------------------------------------------------------

To simplify the symbolic testing of ADTs, PropEr comes with the Auto-ADT
subsystem: An opaque native type, if exported from its module, is assumed to be
an abstract data type, causing PropEr to ignore its internal representation and
instead construct symbolic instances of the type. The API functions used in
these symbolic instances are extracted from the ADT's definition module, which
is expected to contain one or more '-spec'ed exported functions that can be used
to construct instances of the ADT. Specifically, PropEr will use all functions
that return at least one instance of the ADT. As with recursive native types,
the base case is automatically detected (in the case of ADTs, calls to functions
like new/0 and from_list/1 would be considered the base case). The produced
symbolic calls will be '$call' tuples, which are automatically evaluated, thus
no call to eval/1 is required inside the property. Produced instances are
guaranteed to evaluate successfully. Parametric ADTs are fully supported, as
long as they appear instantiated inside ?FORALLs. ADTs hard-coded in the Erlang
type system (array, dict, digraph, gb_set, gb_tree, queue, and set) are
automatically detected and handled as such.

The use of Auto-ADT is currently subject to the following limitations:

* In the ADT's '-opaque' declaration, as in all types' declarations, only
  type variables should be used as parameters in the LHS. None of these
  variables can be the special '_' variable and no variable should appear more
  than once in the parameters.
* ADTs inside specs can only have simple variables as parameters. These
  variables cannot be bound by any is_subtype constraint. Also, the special '_'
  variable is not allowed in ADT parameters. If this would result in singleton
  variables, as in the specs of functions like new/0, use variable names that
  begin with an underscore.
* Specs that introduce an implicit binding among the parameters of an ADT are
  rejected, e.g.:
     -spec foo(dict(T,S),dict(S,T)) -> dict(T,S).
  This includes using the same type variable twice in the parameters of an ADT.
* While parsing the return type of specs in search of ADT references, PropEr
  only recurses into tuples and non-empty lists - all other constructs are
  ignored. This prohibits, among others, indirect references to the ADT through
  other custom types. Another notable rejected construct is the union: return
  values like this one:
     {'ok',ADT} | 'error'
  are not accepted. The only way for an API function to report failure while
  remaining Auto-ADT-compatible is through exceptions.
* When parsing multi-clause specs, only the first clause is considered.
* The only spec constraints we accept are 'is_subtype' constraints whose first
  argument is a simple, non-'_' variable. It is not checked whether or not these
  variables actually appear in the spec. The second argument of an 'is_subtype'
  constraint cannot contain any non-'_' variables. Multiple constraints for the
  same variable are not supported.
* Unexported opaques and opaques with no suitable specs to serve as API calls
  are silently discarded. Those will be treated like ordinary types.
* Unexported or unspecced functions are silently rejected.
* Functions with unsuitable return values are silently rejected.
* Specs that make bad use of variables are silently rejected.

For an example on how to write Auto-ADT-compatible parametric specs, see the
tests/stack module, which contains a simple implementation of a stack, or the
tests/ddict module, which wraps the STDLIB dict ADT.


--------------------------------------------------------------------------------
Errors
--------------------------------------------------------------------------------

The following errors may be encountered during testing. The term provided for
each error is the error type returned by proper:check in case such an error
occurs. Normaly, a message is also printed on screen describing the error.

* 'cant_generate': The instance generation subsystem has failed to produce an
  instance that satisfies some ?SUCHTHAT constraint. You should either increase
  the 'constraint_tries' limit, loosen the failing constraint, or make it
  non-strict. This error should only be encountered during normal operation.
* 'cant_satisfy': All the tests were rejected because no produced test case
  would pass all ?IMPLIES checks. You should loosen the failing ?IMPLIES
  constraint(s). This error should only be encountered during normal operation.
* 'type_mismatch': The variables' and types' structures inside a ?FORALL don't
  match. Please check your properties.
* {'typeserver', <SubError>}: The typeserver encountered an error. The
  <SubError> field contains specific information regarding the error.
* {'unexpected', <Result>}: A test returned an unexpected result during normal
  operation. If you ever get this error, it means that you have found a bug in
  PropEr - please send an error report to the maintainers and remember to
  include both the failing test case and the output of the program, if possible.
* 'wrong_type': Only encountered during re-checking, the counterexample does not
  match the property, since the instances in the counterexample and the types in
  the property don't match.
* 'rejected': Only encountered during re-checking, the counterexample does not
  match the property, since the counterexample doesn't pass an ?IMPLIES check.
* 'too_many_instances': Only encountered during re-checking, the counterexample
  does not match the property, since the counterexample contains more instances
  than there are ?FORALLs in the property.
* 'too_few_instances': Only encountered during re-checking, the counterexample
  does not match the property, since the counterexample contains fewer instances
  than there are ?FORALLs in the property.


--------------------------------------------------------------------------------
Incompatibilities with Quviq QuickCheck
--------------------------------------------------------------------------------

We have generaly tried to keep PropEr's notation and output as compatible as
possible with Quviq QuickCheck, to allow for the reuse of existing testing code
written for QuickCheck. However, incompatibilities are to be expected, since
the two programs probably bear little resemblance under the hood. Here we
provide a nonexhaustive list of known incompatibilities:

* ?SUCHTHATMAYBE behaves differently in PropEr.
* In order to re-check a failing test case, PropEr requires more than the
  instances of the failing test case itself. That required extra bit of
  information is the reason for encapsulating the failing test case in an opaque
  'counterexample' datatype.
* The naming of functions in the main proper module differs slightly from the
  naming of functions in the main eqc module.
* proper_gen:pick differs from eqc_gen:pick in return value format.
* PropEr handles 'size' differently from QuickCheck.
